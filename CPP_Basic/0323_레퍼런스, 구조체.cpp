#include <iostream>
using namespace std;
//구조체
/*
서로 다른 타입의 변수 여러개를 한 번에 묶어서
하나의 사용자정의 변수타입으로 만들어 줄 수 있는 기능이다.
몬스터 정보 : 공, 체 방 등등을 변수 하나하나 해놓으면 불편하다.
이를 구조체로 묶어서 사용하면 편리하게 관리할 수 있다.
struct 키워드를 이용해 사용한다
enum과의 차이: enum은 상수 구조체는 변수
struct 구조체 이름
{
};
*/
struct MonsterInfo
{
	char Name[32];
	int Attack;
	int Armor;
	int HP;
	int MP;
};
struct Test {
	char A;
	int Number;
};

//문제: 이 구조체의 크기는 몇?
struct Test2 {

};
//답: 1
//멤버가 없더라도 최소바이트인 1바이트가 할당된다.
//변수를 선언하게 되면 메모리에 공간이 잡혀야 하므로
// 최소 바이트 수인 

//기본값 기준 해당 구조체의 크기는 4바이트인가 1바이트인가?
//클라이언트가 기본값이고 서버가 1~4바이트 고정이라면 서로 데이터 충돌이 일어난다.

struct Test3 {
	char A;
};
//char A 밖에 없으므로 1바이트다.


int main() {
	/*
	레퍼런스 :  C는 안되고 C++에서만 지원되는 문법
	다른 변수를 참조하여 값을 컨트롤할 수 있다.
	(포인터랑 같은개념 아닌가?)

	요약하면 C++에서 만든 포인터보다 좀 더 사용하기 쉬운 포인터

	특징
	처음 한 번 참조하는 대상이 지정되면 다른 대상을 참조할 수 없다.
	오른쪽 const 같은 느낌

	역참조가 필요없고 바로 접근이 가능하다.(대리인? 중계인 방식인듯)
	*/

	int N = 100;
	int N1 = 200;
	int& Ref = N; //참조하는 방법

	Ref = 2020; //Ref는 대리인, 바꿔줄 수도 없음
	            // N을 100에서 2020으로 바꿔준다.
	cout << N << std::endl;

	//포인터에 대한 레퍼런스
	int* pN = &N;
	int*& pRef = pN;

	pRef = &N1; // N1에 대한 주소를 참조하게 된다.
				// 이중포인터랑 비슷한 느낌
				// 차이점은 역참조 없이 바로 접근이 가능하다.
	cout << *pN << std::endl;

	//구조체 파트

	//구조체 선언 뒤에 = {} 하면 모든 멤버를 0으로 초기화
	// == 배열과 같은 원리
	// == 구조체도 배열처럼 연속된 메모리에 할당

	//MonsterInfo Monster1 = { "오크", 10, 5, 50, 10 }; //이런식으로 초기화 가능
	MonsterInfo Monster1 = {}; //전부 0으로 초기화

	//구조체 변수에 접근하기
	cout << "이름 : " << Monster1.Name << endl;
	//구조체 변수의 크기?
	//안에 들어있는 변수 크기들의 합
	//단 절대적이진 않음 (test 구조체 참고)
	cout << sizeof(Test) << endl; //이러면 8바이트가 나옴
	//char a를 4바이트 공간을 할당받고 1바이트만 사용하기 때문

	//@ 포인터 배열로 써서 사용하기

	//연산자 우선순위
	return 0;
}